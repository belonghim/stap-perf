#!/usr/bin/env -S stap -g --all-modules

%{ /* pure */
#include <net/route.h>
#include <linux/skbuff.h>
#include <linux/icmp.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
%}

function __skb_linear_data:long(skb:long, offset:long)
%{ /* pure */
   struct sk_buff *skb;
   uintptr_t buf;

   skb = (struct sk_buff *)(uintptr_t)STAP_ARG_skb;

   kderef_buffer(NULL, skb, sizeof(struct sk_buff));
   buf = (uintptr_t)((char *)skb_mac_header(skb) + STAP_ARG_offset);
   STAP_RETVALUE = *(unsigned char *)buf;
   CATCH_DEREF_FAULT();
%}

function __skb_len:long(skb:long)
%{ /* pure */
   struct sk_buff *skb;

   skb = (struct sk_buff *)(uintptr_t)STAP_ARG_skb;

   STAP_RETVALUE = skb->len;
   CATCH_DEREF_FAULT();
%}

function __get_skb_icmphdr:long(skb:long)
%{ /* pure */
   struct sk_buff *skb;
   skb = (struct sk_buff *)(uintptr_t)STAP_ARG_skb;

   kderef_buffer(NULL, skb, sizeof(struct sk_buff));
   STAP_RETVALUE = (long)skb_network_header(skb) + sizeof(struct iphdr);
   CATCH_DEREF_FAULT();
%}

@define icmphdr_cast(ptr) %(
        @cast(@ptr, "icmphdr", "kernel<uapi/linux/icmp.h>")
%)

function __icmp_code:long (icmphdr)
{
  return @icmphdr_cast(icmphdr)->code
}

function __icmp_type:long (icmphdr)
{
  return @icmphdr_cast(icmphdr)->type
}

probe kernel.{function("dev_set_mtu"),function("change_mtu")} {
	name = get_netdev_name($dev);
        old = $dev->mtu;
	printf("[%d] (%s:%d) device %s change mtu from %d to %d\n", ktime_get_ns(), execname(), pid(), name, old, $new_mtu);
	print_backtrace();
}

function skb_linear_print (skb)
{
        skb_len_to_print = __skb_len(skb);
        skb_len = __skb_len(skb);

        while (skb_len_to_print) {
            next_batch = skb_len_to_print;
            if (next_batch < 8) {
                next_batch = 0;
            } else {
                next_batch -= 8;
            }
            printf("0x%08x:   ", skb_len - skb_len_to_print);

            while (skb_len_to_print > next_batch) {
                printf(" 0x%02x", 0xff & __skb_linear_data(skb, skb_len - skb_len_to_print));
                skb_len_to_print -= 1;
            }
            printf("\n");
        }
}

probe kernel.{function("icmp_rcv"),function("icmp_unreach"),function("icmp_reply"),function("ipv4_update_pmtu"),function("ip_rt_update_pmtu"),function("ipv4_sk_update_pmtu")} {
            skb = $skb;
            icmphdr = __get_skb_icmphdr(skb);
            code = 0;
            type = 0;

            if (icmphdr) {
                code = __icmp_code(icmphdr);
                type = __icmp_type(icmphdr);
            }

            printf("[%d] Handle possible RT Exception (%s, %d, %d)\n", ktime_get_ns(), probefunc(), type, code);
            if (probefunc() =~ "icmp_reply.*") {
               printf("Generic ICMP (%u) %d:%d\n", uid(), type, code);
            } else if (type != 0 && type != 8) {
               printf("Unreachable message in (%s:%d %d/%d)\n", execname(), pid(), type, code);
               if (type == 3 && code == 4) {
                   print_backtrace();
                   printf("====================================\n");
                   printf("skb: indev[%s]\n", kernel_string($skb->dev->name));
                   skb_linear_print(skb);
                   printf("====================================\n");
               }
            }
}

probe kernel.{function("fib_table_insert"),function("fib_table_delete")} {
	cfg = $cfg;
	printf("[%d] FIB table insert/delete called with gw: %08x / %08x, netns ptr: %p\n", ktime_get_ns(), cfg->fc_dst, cfg->fc_gw, $net);
	print_backtrace();
}

probe kernel.function("__icmp_send") {
      type = $type;
      code = $code;
      //printf("Gen possible RT Exception (%s, %d, %d)\n", probefunc(), type, code);
      if (type == 3) {
          printf("[%d] ICMP Dest unreachable (%d) generated by (%s:%d)\n", ktime_get_ns(), code, execname(), pid());
          print_backtrace();
      }
}

function RETVAL_IS_ERR:long(ptr:long)
%{ /* pure */
   STAP_RETVALUE = IS_ERR((const void *)(uintptr_t)STAP_ARG_ptr);
%}
   
probe kernel.function("skb_segment").return {
    if (RETVAL_IS_ERR($return)) {
        printf("[%d] skbseg return == %d (%s)\n", ktime_get_ns(), $return, execname());
    }
}
